/**
 * @deprecated 请优先从 `src/ui/services/index.ts` 导入 API（公共门面）。
 * 本文件在后续版本会被拆分为分域服务并逐步移除。
 */
import type {
  ExecutionRecord,
  PendingApprovalEntry,
  RuntimeToolStreamPayload,
  ToolStreamSummary
} from "../types/orchestrator";
import type { PlanJson } from "../components/graph/PlanCanvas";

const DEFAULT_BASE_URL = "http://127.0.0.1:3000/api/v1";

export async function fetchPlanById(planId: string): Promise<PlanJson | null> {
  const url = `${getBaseUrl()}/plans/${encodeURIComponent(planId)}`;
  try {
    const response = await fetch(url);
    if (!response.ok) {
      return null;
    }
    const text = await response.text();
    try {
      return JSON.parse(text) as PlanJson;
    } catch {
      return null;
    }
  } catch {
    return null;
  }
}

// —— 示例计划 ——
export async function fetchExamplePlans(): Promise<Array<{ name: string; plan?: unknown }>> {
  const res = await fetch(`${getBaseUrl()}/plans/examples`);
  if (!res.ok) return [];
  const json = (await res.json().catch(()=>({}))) as { examples?: Array<{ name: string; plan?: unknown }> };
  return json.examples ?? [];
}
export async function importExamplePlan(name: string): Promise<{ id: string } | null> {
  const res = await fetch(`${getBaseUrl()}/plans/examples/${encodeURIComponent(name)}/import`, { method: 'POST' });
  if (!res.ok) return null;
  return (await res.json()) as { id: string };
}

// —— FS API 封装 ——
export type FSScope = 'plansRepo' | 'plansConfig' | 'state' | 'archives' | 'logs';
export interface FSEntry { name: string; type: 'file'|'dir'; size: number; modifiedAt: string }
export async function fsList(scope: FSScope, path = '.') { const res = await fetch(`${getBaseUrl()}/fs/list?scope=${scope}&path=${encodeURIComponent(path)}`); if (!res.ok) throw new Error('list failed'); const json = await res.json() as { entries: FSEntry[] }; return json.entries; }
export async function fsRead(scope: FSScope, path: string) { const res = await fetch(`${getBaseUrl()}/fs/read?scope=${scope}&path=${encodeURIComponent(path)}`); if (!res.ok) throw new Error('read failed'); return (await res.json() as { content: string }).content; }
export async function fsWrite(scope: FSScope, path: string, content: string, overwrite = true) { const res = await fetch(`${getBaseUrl()}/fs/write`, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ scope, path, content, overwrite }) }); if (!res.ok) throw new Error('write failed'); return true; }
export async function fsMkdir(scope: FSScope, path: string) { const res = await fetch(`${getBaseUrl()}/fs/mkdir`, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ scope, path }) }); if (!res.ok) throw new Error('mkdir failed'); return true; }
export async function fsMove(scope: FSScope, from: string, to: string) { const res = await fetch(`${getBaseUrl()}/fs/move`, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ scope, from, to }) }); if (!res.ok) throw new Error('move failed'); return true; }
export async function fsDelete(scope: FSScope, path: string, recursive = false) { const res = await fetch(`${getBaseUrl()}/fs/delete`, { method: 'DELETE', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ scope, path, recursive }) }); if (!res.ok) throw new Error('delete failed'); return true; }

export function buildToolStreamExportUrl(executionId: string, correlationId: string, opts?: { format?: 'json'|'ndjson'; compress?: boolean }) {
  const base = getBaseUrl();
  const fmt = opts?.format ?? 'json';
  const comp = opts?.compress ? '1' : '0';
  return `${base}/executions/${encodeURIComponent(executionId)}/tool-streams/${encodeURIComponent(correlationId)}/export?format=${fmt}&compress=${comp}`;
}

export function buildGlobalToolStreamExportUrl(correlationId: string, opts?: { format?: 'json'|'ndjson'; compress?: boolean }) {
  const base = getBaseUrl();
  const fmt = opts?.format ?? 'json';
  const comp = opts?.compress ? '1' : '0';
  return `${base}/tool-streams/${encodeURIComponent(correlationId)}/export?format=${fmt}&compress=${comp}`;
}

export interface CompileResponse { plan: unknown; diagnostics: Array<{ code?: string; severity: string; message: string; nodeId?: string; edgeId?: string }> }
export async function compileGraph(graph: { nodes: any[]; edges: any[] }, opts?: { signal?: AbortSignal }): Promise<CompileResponse> {
  const res = await fetch(`${getBaseUrl()}/designer/compile`, {
    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ graph }), signal: opts?.signal
  });
  if (!res.ok) {
    const body = (await res.json().catch(()=>({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `compile 失败 (${res.status})`);
  }
  return (await res.json()) as CompileResponse;
}

export interface DryRunSimResponse { timeline?: unknown[]; warnings?: string[] }
export async function simulateDryRun(plan: unknown, opts?: { fromNode?: string; signal?: AbortSignal }): Promise<DryRunSimResponse> {
  const res = await fetch(`${getBaseUrl()}/plans/dry-run`, {
    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ plan, fromNode: opts?.fromNode, dryRun: true }), signal: opts?.signal
  });
  if (!res.ok) {
    const body = (await res.json().catch(()=>({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `dry-run 失败 (${res.status})`);
  }
  return (await res.json()) as DryRunSimResponse;
}

export function getBaseUrl(): string {
  const value = import.meta.env.VITE_ORCHESTRATOR_BASE_URL;
  if (typeof value === "string" && value.trim().length > 0) {
    return value.replace(/\/$/, "");
  }
  return DEFAULT_BASE_URL;
}

export async function fetchExecutions(signal?: AbortSignal): Promise<ExecutionRecord[]> {
  const url = `${getBaseUrl()}/executions`;
  const response = await fetch(url, { signal });
  if (!response.ok) {
    throw new Error(`获取执行列表失败 (${response.status})`);
  }
  const body = (await response.json()) as { executions: ExecutionRecord[] };
  return body.executions;
}

export async function fetchExecutionById(id: string): Promise<ExecutionRecord> {
  const res = await fetch(`${getBaseUrl()}/executions/${encodeURIComponent(id)}`);
  if (!res.ok) {
    const body = (await res.json().catch(()=>({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取执行失败 (${res.status})`);
  }
  return (await res.json()) as ExecutionRecord;
}

export function createWebSocket(topics: string[]): WebSocket {
  const baseUrl = getBaseUrl();
  const wsUrl = new URL(baseUrl);
  wsUrl.protocol = wsUrl.protocol === "https:" ? "wss:" : "ws:";
  wsUrl.pathname = "/ws";
  if (topics.length > 0) {
    wsUrl.searchParams.set("topics", topics.join(","));
  }
  return new WebSocket(wsUrl);
}

interface DryRunResponse {
  planId: string;
  warnings: string[];
}

interface ExecuteResponse {
  executionId: string;
  status: string;
  planId: string;
}

export async function dryRunPlan(plan: unknown): Promise<DryRunResponse> {
  const response = await fetch(`${getBaseUrl()}/plans/validate`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ plan })
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `dry-run 失败 (${response.status})`);
  }
  return (await response.json()) as DryRunResponse;
}

export async function executePlan(plan: unknown, serverName?: string): Promise<ExecuteResponse> {
  const response = await fetch(`${getBaseUrl()}/plans/execute`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      plan,
      mcpServer: serverName
    })
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `执行计划失败 (${response.status})`);
  }
  return (await response.json()) as ExecuteResponse;
}

export async function executePlanById(planId: string, serverName?: string): Promise<ExecuteResponse> {
  const response = await fetch(`${getBaseUrl()}/plans/${encodeURIComponent(planId)}/execute`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ mcpServer: serverName })
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `执行计划(${planId})失败 (${response.status})`);
  }
  return (await response.json()) as ExecuteResponse;
}

export async function submitApprovalDecision(
  id: string,
  decision: "approved" | "rejected",
  comment?: string
): Promise<void> {
  const response = await fetch(`${getBaseUrl()}/approvals/${encodeURIComponent(id)}/decision`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ decision, comment })
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `提交审批失败 (${response.status})`);
  }
}

export async function stopExecution(id: string): Promise<void> {
  const response = await fetch(`${getBaseUrl()}/executions/${encodeURIComponent(id)}/stop`, {
    method: "POST"
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `停止执行失败 (${response.status})`);
  }
}

export interface McpToolDescriptor {
  name: string;
  description?: string;
}

export interface McpServerSummary {
  name: string;
  description?: string;
}

export async function fetchMcpServers(): Promise<McpServerSummary[]> {
  const response = await fetch(`${getBaseUrl()}/mcp/servers`);
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取 MCP 配置列表失败 (${response.status})`);
  }
  const payload = (await response.json()) as { servers?: McpServerSummary[] };
  return payload.servers ?? [];
}

export async function fetchMcpTools(serverName?: string): Promise<McpToolDescriptor[]> {
  const url = new URL(`${getBaseUrl()}/mcp/tools`);
  if (serverName) {
    url.searchParams.set("mcpServer", serverName);
  }
  const response = await fetch(url);
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取 MCP 工具失败 (${response.status})`);
  }
  const payload = (await response.json()) as { tools: McpToolDescriptor[] };
  return payload.tools ?? [];
}

export async function callMcpTool(toolName: string, payload: unknown, serverName?: string): Promise<unknown> {
  const response = await fetch(`${getBaseUrl()}/mcp/tools/${encodeURIComponent(toolName)}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      arguments: payload,
      mcpServer: serverName
    })
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `调用 MCP 工具失败 (${response.status})`);
  }
  const result = (await response.json()) as { result: unknown };
  return result.result;
}

export interface RequestApprovalPayload {
  executionId?: string;
  planId?: string;
  planVersion?: string;
  nodeId?: string;
  nodeType?: string;
  riskLevel?: "low" | "medium" | "high";
  requiresApproval?: boolean;
  requestedBy?: string;
  metadata?: Record<string, unknown>;
  title?: string;
}

export async function requestApproval(payload: RequestApprovalPayload): Promise<PendingApprovalEntry> {
  const response = await fetch(`${getBaseUrl()}/approvals/request`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `创建审批请求失败 (${response.status})`);
  }
  const result = (await response.json()) as { approval: PendingApprovalEntry };
  return result.approval;
}

export async function fetchExecutionToolStreamSummaries(executionId: string): Promise<ToolStreamSummary[]> {
  const response = await fetch(`${getBaseUrl()}/executions/${encodeURIComponent(executionId)}/tool-streams`);
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取流式历史失败 (${response.status})`);
  }
  const payload = (await response.json()) as { streams?: ToolStreamSummary[] };
  return payload.streams ?? [];
}

export async function fetchGlobalToolStreamSummaries(params?: { executionId?: string; onlyErrors?: boolean; limit?: number; offset?: number; tool?: string; correlationPrefix?: string; updatedAfter?: string; updatedBefore?: string }): Promise<{ total: number; streams: ToolStreamSummary[] }> {
  const base = new URL(`${getBaseUrl()}/tool-streams`);
  if (params?.executionId) base.searchParams.set('executionId', params.executionId);
  if (typeof params?.onlyErrors === 'boolean') base.searchParams.set('onlyErrors', params.onlyErrors ? '1' : '0');
  if (typeof params?.limit === 'number') base.searchParams.set('limit', String(params.limit));
  if (typeof params?.offset === 'number') base.searchParams.set('offset', String(params.offset));
  if (params?.tool) base.searchParams.set('tool', params.tool);
  if (params?.correlationPrefix) base.searchParams.set('correlationPrefix', params.correlationPrefix);
  if (params?.updatedAfter) base.searchParams.set('updatedAfter', params.updatedAfter);
  if (params?.updatedBefore) base.searchParams.set('updatedBefore', params.updatedBefore);
  const res = await fetch(base);
  if (!res.ok) {
    const body = (await res.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取全局流式历史失败 (${res.status})`);
  }
  const payload = (await res.json()) as { total?: number; streams?: ToolStreamSummary[] };
  return { total: payload.total ?? (payload.streams?.length ?? 0), streams: payload.streams ?? [] };
}

export async function fetchExecutionToolStreamChunks(
  executionId: string,
  correlationId: string
): Promise<RuntimeToolStreamPayload[]> {
  const response = await fetch(
    `${getBaseUrl()}/executions/${encodeURIComponent(executionId)}/tool-streams/${encodeURIComponent(correlationId)}`
  );
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取流式输出明细失败 (${response.status})`);
  }
  const payload = (await response.json()) as { chunks?: RuntimeToolStreamPayload[] };
  return payload.chunks ?? [];
}

export async function fetchGlobalToolStreamChunks(correlationId: string): Promise<RuntimeToolStreamPayload[]> {
  const res = await fetch(`${getBaseUrl()}/tool-streams/${encodeURIComponent(correlationId)}`);
  if (!res.ok) {
    const body = (await res.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `获取全局流式输出失败 (${res.status})`);
  }
  const payload = (await res.json()) as { chunks?: RuntimeToolStreamPayload[] };
  return payload.chunks ?? [];
}

export async function replayExecutionToolStream(executionId: string, correlationId: string): Promise<number> {
  const response = await fetch(
    `${getBaseUrl()}/executions/${encodeURIComponent(executionId)}/tool-streams/${encodeURIComponent(correlationId)}/replay`,
    {
      method: "POST"
    }
  );
  if (!response.ok) {
    const body = (await response.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `重放流式输出失败 (${response.status})`);
  }
  const payload = (await response.json()) as { replayed: number };
  return payload.replayed;
}

// —— 计划 CRUD（可选：若后端提供 /plans API）——
export interface PlanSummary { id: string; description?: string; version?: string }

export async function fetchPlans(): Promise<PlanSummary[]> {
  const res = await fetch(`${getBaseUrl()}/plans`);
  if (!res.ok) return [];
  const json = (await res.json().catch(() => ({}))) as { plans?: PlanSummary[] };
  return json.plans ?? [];
}

export async function createPlan(plan: unknown): Promise<{ id: string }> {
  const res = await fetch(`${getBaseUrl()}/plans`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ plan }) });
  if (!res.ok) {
    const body = (await res.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `创建计划失败 (${res.status})`);
  }
  const json = (await res.json()) as { id: string };
  return json;
}

export async function updatePlan(planId: string, plan: unknown): Promise<void> {
  const res = await fetch(`${getBaseUrl()}/plans/${encodeURIComponent(planId)}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ plan }) });
  if (!res.ok) {
    const body = (await res.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `更新计划失败 (${res.status})`);
  }
}

export async function deletePlan(planId: string): Promise<void> {
  const res = await fetch(`${getBaseUrl()}/plans/${encodeURIComponent(planId)}`, { method: 'DELETE' });
  if (!res.ok) {
    const body = (await res.json().catch(() => ({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `删除计划失败 (${res.status})`);
  }
}

export async function uploadPlanFiles(files: File[]): Promise<{ imported: number; ids: string[] } | null> {
  const fd = new FormData();
  for (const f of files) fd.append('file', f);
  const res = await fetch(`${getBaseUrl()}/plans/upload`, { method: 'POST', body: fd as any });
  if (!res.ok) return null;
  return (await res.json()) as { imported: number; ids: string[] };
}

// —— 调度只读 ——
export interface ScheduleItem { planId: string; cron: string; file: string; dir: string; source: 'repo' | 'config'; nextRunISO: string | null; lastRun: { executionId: string; status: string; startedAt?: string; finishedAt?: string } | null }
export async function fetchSchedules(): Promise<ScheduleItem[]> {
  const res = await fetch(`${getBaseUrl()}/schedules`);
  if (!res.ok) return [];
  const json = (await res.json().catch(() => ({}))) as { schedules?: ScheduleItem[] };
  return json.schedules ?? [];
}

export async function reloadSchedules(): Promise<number> {
  const res = await fetch(`${getBaseUrl()}/schedules/reload`, { method: 'POST' });
  if (!res.ok) {
    const body = (await res.json().catch(()=>({}))) as { error?: { message?: string } };
    throw new Error(body.error?.message ?? `重载调度失败 (${res.status})`);
  }
  const payload = (await res.json()) as { count: number };
  return payload.count ?? 0;
}
